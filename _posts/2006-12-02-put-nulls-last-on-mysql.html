---
layout: post
title: Put NULLS Last on MySQL
date: 2006-12-02 14:34:06.000000000 -08:00
type: post
published: true
status: publish
categories:
- Ruby on Rails
- SQL
tags: []
meta:
  _edit_last: '530919'
author:
  login: bburcham
  email: bill.burcham@gmail.com
  display_name: Bill Burcham
  first_name: ''
  last_name: ''
---
<p>NULLs are a wonderful but strange feature of SQL.  They are the source of some deep coolness but also some lost hair.  One place where NULLs can bite you is when you are sorting. The way you sort in SQL is by appending the <code>ORDER BY</code> clause to the end of a <code>SELECT</code> statement.  The problem is that the SQL standards say that for the purpose of sorting, NULL = NULL but they don't specify how NULL values should be ordered relative to non-NULL ones.  Doh!</p>
<p>In this post I describe the solution to this problem in the context of MySQL and Ruby on Rails.<br />
<!--more--></p>
<p>Now imagine you've got a Ruby on Rails app that manages <i>shipments</i> and those shipments have an attribute called <code>expected_at</code>:</p>
<pre class="textmate-source twilight"><span class="linenum">    1</span> <span class="source source_ruby">      t.column <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:expected_at</span>, <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:datetime</span></span></pre>
<p>And then let's say you'd like to present a list of shipments ordered by their expected time.  You'd like shipments expected soonest to appear before shipments expected later.  You might have a core snippet of code like this:</p>
<pre class="textmate-source twilight"><span class="linenum">    1</span> <span class="source source_ruby source_ruby_rails"><span class="variable variable_other variable_other_readwrite variable_other_readwrite_instance variable_other_readwrite_instance_ruby">@sorted_shipments</span> = association.find(
<span class="linenum">    2</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:all</span>,
<span class="linenum">    3</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:order</span> =&gt; <span class="string string_quoted string_quoted_single string_quoted_single_ruby">'expected_at ASC'</span>,
<span class="linenum">    4</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:limit</span> =&gt; <span class="variable variable_other variable_other_readwrite variable_other_readwrite_instance variable_other_readwrite_instance_ruby">@shipment_pages</span>.items_per_page,
<span class="linenum">    5</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:offset</span> =&gt; <span class="variable variable_other variable_other_readwrite variable_other_readwrite_instance variable_other_readwrite_instance_ruby">@shipment_pages</span>.current.offset)
</span></pre>
<p>Now what happens if you don't know the expected time for a shipment?  Well the natural thing to do in SQL is to leave the value NULL.  Now the problem arises.  If for instance you're running on MySQL, shipments with NULL <code>expected_at</code> times will appear <i>before</i> those with non-NULL ones.  So what can you do?</p>
<p>Well my first thought was to have two separate associations -- one for shipments that had NULL <code>expected_at</code> times and a second one for those that didn't.  The problem with that approach (if you're using the Ruby on Rails Paginator framework) is that it leaves you to do a bunch of bookkeeping in application code.  You really don't want to hand code pagination over multiple associations.  Or I should say -- <i>I</i> certainly don't want to.</p>
<p>My second thought was that I was missing some key knowledge of Ruby on Rails.  When in doubt -- assume that Rails has thought of it.  But a fair amount of spelunking turned up nothing.  Rails is mute on this issue.</p>
<p>So where to turn next?  The database of course!  An initial search for "sql sort null"  led me to an Oracle <a href="http://www.xquery.com/white_papers/generating_sql/sorting-data.html">reference</a> that mentioned Oracle's <code>NULLS LAST</code> clause.  When I tried <code>NULLS LAST</code> on MySQL, naturally it failed. MySQL doesn't support it.  A subsequent search for "mysql nulls last" yielded <a href="http://troels.arvin.dk/db/rdbms/">gold</a>.  Turns out there is an obscure syntax available in MySQL which you can use to control the relative ordering of NULL and non-NULL values:</p>
<blockquote><p>NULLs are considered lower than any non-NULL value, except if a - (minus) character is added before the column name and ASC is changed to DESC, or DESC to ASC; this minus-before-column-name feature seems undocumented.</p></blockquote>
<p>Clear enough.  Er.  Not very.  If you're like me you need an example.  To make the previous example do what we want, here's what the code looks like now:</p>
<pre class="textmate-source twilight"><span class="linenum">    1</span> <span class="source source_ruby source_ruby_rails"><span class="variable variable_other variable_other_readwrite variable_other_readwrite_instance variable_other_readwrite_instance_ruby">@sorted_shipments</span> = association.find(
<span class="linenum">    2</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:all</span>,
<span class="linenum">    3</span>   <span class="comment comment_line comment_line_number-sign comment_line_number-sign_ruby"># this is the same as doing 'expected_at ASC NULLS LAST' on Oracle</span>
<span class="linenum">    4</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:order</span> =&gt; <span class="string string_quoted string_quoted_single string_quoted_single_ruby">'-expected_at DESC'</span>,
<span class="linenum">    5</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:limit</span> =&gt; <span class="variable variable_other variable_other_readwrite variable_other_readwrite_instance variable_other_readwrite_instance_ruby">@shipment_pages</span>.items_per_page,
<span class="linenum">    6</span>   <span class="constant constant_other constant_other_symbol constant_other_symbol_ruby">:offset</span> =&gt; <span class="variable variable_other variable_other_readwrite variable_other_readwrite_instance variable_other_readwrite_instance_ruby">@shipment_pages</span>.current.offset)</span></pre>
<p>So that's... stick a minus in front of the column name and invert the apparent sense of the ordering.  Now you'll get earlier arrivals before later ones and you'll get NULL's (indeterminate arrivals) at the very end.  Whew.</p>
