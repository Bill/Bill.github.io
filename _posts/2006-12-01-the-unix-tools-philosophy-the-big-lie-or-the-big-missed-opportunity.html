---
layout: post
title: 'The Unix tools philosophy: The Big Lie or The Big Missed Opportunity?'
date: 2006-12-01 14:15:52.000000000 -08:00
type: post
published: true
status: publish
categories:
- One Step Forward
tags: []
meta: {}
author:
  login: bburcham
  email: bill.burcham@gmail.com
  display_name: Bill Burcham
  first_name: ''
  last_name: ''
---
<p>The Unix tools philosophy is so well known and oft-repeated that it has become mantra to many.  As with so many habitual, memorized responses, like blessing someone after a sneeze, we rarely think deeply about the words said, and what they really mean.  We don't notice that while we praise this approach, we almost never use it for anything serious.</p>
<p><!--more--></p>
<h4>The Unix Philosophy</h4>
<p>The first reference I heard of to the Unix philosophy was in the seminal 1978 Bell Systems Technical Journal special edition on Unix. (Appropriately, if you <a href="http://www.lucent.com/minds/techjournal/">go</a> to the <strike>Bell Labs</strike>. <strike>Lucent</strike>, Alcatel (?) web site to subscribe to this journal, you'll find it has literally gone 404).  Again and again, this philosophy has been repeated. I've seen it most recently on Duncan Davidson's <a href="http://blog.duncandavidson.com/2006/06/the_web_is_a_pi.html">Web is a pipe</a> blog entry.  Sadly, his otherwise insightful post has an example that does not demonstrate the value of pipes, but rather a <a href="http://partmaps.org/era/unix/award.html">Useless use of cat</a>.<br />
The Unix philosophy, is described quite well on wikipedia, attributed to Doug McIllroy:</p>
<blockquote><p>This is the Unix philosophy:</p>
<p>Write programs that do one thing and do it well.</p>
<p>Write programs to work together.</p>
<p>Write programs to handle text streams, because that is a universal interface.</p></blockquote>
<h4>The Big Lie</h4>
<p>This is the Motherhood and Apple Pie of programming.  It sounds great in some idealized world, but we rarely see it in our world. Think of the Unix applications you spend the most time using every day.  For me, it is something like compiler, editor, web browser, web server, database server.  None of these are built from a large set of small tools hooked up with pipes transmitting ASCII data.  Not one single application.  Yes, I know about gcc and the -pipe option, but this doesn't count -- gcc doesn't read standard input, and the five (or so) stages of the compiler hardly qualify as small, reusable components.  Historical tidbit: In the 2BSD days, the C compiler's optimizer was implemented as an awk script that ran over the assembler input.  But now that we expect our compilers to do more than peephole optimizations, we don't do this kind of thing anymore.</p>
<p>Now, I use the Unix command line every day, and frequently string together shell one-liners.  I build histograms with<br />
<code>sort | uniq -c | sort -n</code></p>
<p>idiomatically.  But I don't build large applications this way.  Almost no one does. Does this mean that the Unix philosophy only applies to interactive shell programming?  Or perhaps to that and one level higher, smallish shell scripts (but certainly nothing the size of a C compiler)?  Or was the intention of the Unix designers that their machines, tiny by today's standards would mainly run small shell scripts? I would love to ask Thompson, Richie, or any of the other Bell Labs folks these questions.  It is ironic that we are <strong>more</strong> concerned/obsessed with performance on today's machines that are thousands of times faster and cheaper than the PDP-11s Unix was born on.</p>
<h4>Solutions to the dilemma</h4>
<p>One "solution" is to admit defeat, and say that the Unix Philosophy doesn't really work, at least not on big programs or anything more complicated than a shell one-liner.  After all, most Windows users, even power-users, never use command pipelines.  Instead of the three command pipeline above to create a histogram, a Windows power user would probably load the data up in Excel, and go from there.  Maybe that isn't as elegant, but it gets the job done just as easily as the shell command.  If this is your solution to this dilemma, I would ask you to at least <strong>be honest</strong> about your retreat -- if you don't build programs this way, stop proclaiming its superiority.  Please.  There are plenty of sucessful projects in the <a href="http://www.perl.com/pub/a/1999/03/pm.html#jump4">other camp</a>, and they are up-front about violating all three tenets.</p>
<p>Another solution is to claim that the problem is that the unidirectional ASCII streams aren't structured enough, and to add some more structure and state, and create a full-blown RPC mechanism.   In terms of the Unix Philosophy quoted above, we remove the third leg of the tripod (<em>Write programs to handle text streams, because that is a universal interface</em>).  Once this is done, the sin of premature optimization is inevitably commited, for there is the fear that bundling each component into a separate Unix process will lead to performance problems.  So, the word "program" is struck out of the philosophy, and replaced with the word "component", with convenient vagueness. Once these changes are made, we've pretty much given up on the validity or usefulness of the original philosophy.</p>
<p>This is the path that SunRPC, CORBA, DCOM, and XPCOMM take.  While each of these have been successful within limited domains, we don't see any of them used as toolkits to quickly build many, diverse applications by non-experts.  Rather, they are used to glue together predefined puzzle pieces in predefined ways.  For example, as Firefox is composed of many XPCOMM components, why can't I break apart the components, and quickly build, say, an IM client out of those components? Ho-ho, I hear you say, what about <a href="http://www.mozilla.org/projects/rt-messaging/chatzilla/">Chatzilla</a>?  Chatzilla is built from over a dozen Javascript files by an expert javascript/XUL developer.  I would categorize this as an exception that proves the rule -- if it really were easy to build this up, there would be dozens of them.  Especially the first three component techologies mentioned above, make it <strong>hard</strong> to connect up various components, especially those which haven't been planned to interoperate <em>a-priori</em>.  The Unix philosophy stresses easy of connectability.</p>
<h4>Why not try?</h4>
<p>A wise man once told me, "If there's one thing I've learned in six years of graduate study in Computer Science, it is the value of a Unix process".  So, why not try it, and build real, large applications out of smaller unix processes connected by pipes?  There's even precedent -- the applications that <a href="http://cr.yp.to/djb.html">Dan Bernstein</a> has written, like <a title="Qmail -- the big picture" href="http://www.nrg4u.com/qmail/the-big-qmail-picture-103-a4.pdf">qmail</a> and djbdns.  These systems, primarily designed for security, are composed of many processes which communicate via ASCII stream over pipes.  And guess what?  qmail is secure, gives good performance, and there are many add-ons and replacements for its various components.  Maybe, in this age when folks worry about how to effectively use quad-core CPUs, just maybe the <a href="http://www.nationalmedals.org/assets/images/Lucent.jpg">graybeards</a> knew a thing or two after all.</p>
